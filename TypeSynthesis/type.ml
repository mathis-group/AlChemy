(* 
    File: type.ml
    
    Walter Fontana, Vienna 1995 
*)

#open "lex";;
#open "lambdatype";;
#open "parse";;
#open "utils";;
#open "basis";;
#open "printers";;

let counter = ref 0;;

(*---------------------------------------------------------------------*)
(*--- Generating and resetting unknowns -------------------------------*)
(*---------------------------------------------------------------------*)

let new_vartype, reset_vartypes =
  (
    function () -> counter := !counter + 1; 
		  {Index = !counter; Value = Unknown}
  ),
  (
    function () -> counter := 0; ()
  )
;;

(*--------------------------------------------------------------------*)
(*--- list of type variables -----------------------------------------*)
(*--------------------------------------------------------------------*)

let vars_of_type tau = vars [] tau
    where rec vars vs = function 
        Atom str                            -> vs
      | TypeVar{Index = n; Value = Unknown} -> if mem n vs then vs
                                                 else n :: vs
      | TypeVar{Index = _; Value = t}       -> vars vs t
      | Arrow(t1,t2)                        -> vars (vars vs t1) t2
      | Unknown                             -> raise (TypingBug "vars_of_type")
;;

(*--------------------------------------------------------------------*)
(*--- list of free type variables of environment ---------------------*)
(*--------------------------------------------------------------------*)
(*
    unbound type variables cannot become generic (bound by a 
    universal quantifier)
*)

(*---------------------------------------------------------------------*)

let unknowns_of_type (bv,t) = subtract (vars_of_type t) bv;;

(*---------------------------------------------------------------------*)

let flat = it_list (prefix @) []
;;

let unknowns_of_type_env env =
    flat (map (function Forall(gv,t) -> unknowns_of_type (gv,t)) env)
;;

(*---------------------------------------------------------------------*)
(*--- Initialize typing environment -----------------------------------*)
(*---------------------------------------------------------------------*)
(*
    assign type schemes to the variables in the initial environment
*)

(*---------------------------------------------------------------------*)
(* 
    allocate bound type variables for use in copy_type
    (these are local to a type scheme)
*)

let bound_list gv = 
  map (function n -> n, TypeVar(new_vartype())) gv
;;

(*---------------------------------------------------------------------*)
(* 
    allocate unbound type variables for use in copy_type
    (these are shared among all type schemes in the environment)
*)

let free_list env = 
  map (function n -> n, TypeVar(new_vartype()))
    (make_set (unknowns_of_type_env
      (subtract (map (function (x,ts,i) -> ts) env) [Forall([],Unknown)])))
;;

(*---------------------------------------------------------------------*)
(* 
    copy a type using the type variables allocated in list "vl" 
    (generated by bound_list and free_list). the multiple occurrences of a 
    variable get, therefore, linked (important in destructive unification).
*)

let copy_type vl =
  let rec copy = function
      TypeVar{Index = n; Value = Unknown} -> (try assoc n vl with Not_found 
                                              -> raise (TypingBug "copy_type"))
    | Arrow(t1,t2)			  -> Arrow(copy t1,copy t2)
    | Atom str				  -> Atom str
    | Unknown				  -> Unknown  
    | TypeVar{Index = _; Value = t}	  -> raise (TypingBug "copy_type")
  in 
  copy
;;

(*---------------------------------------------------------------------*)
(*
    generate an integer sequence from 1 to length
*)

let sequence length =
  let rec make_sequence list n =
    if n > length then list
    else make_sequence (n :: list) (succ n)
  in make_sequence [] 1
;;

(*---------------------------------------------------------------------*)
(*
    reset counters and generate a global typing environment from the
    environment list produced by the parser.
*)

let generate_typing_env env =
  reset_vartypes ();
  if env = [] then []
  else (
    let fl = free_list env
    in
    let unbounds = sequence (list_length fl)  
    (* {1...length} are the unbound vars! *)
    in
    let build_type_scheme s = 
      if s = Forall([],Unknown) then 
	(* generalise a new type variable *)
	let u = TypeVar(new_vartype()) in Forall([!counter],u)
      else 
	(* build a fresh type scheme *)
	match s with Forall(gv,tau) -> 
	      let t = copy_type ((bound_list gv) @ fl) tau
	      in
	      let bv = make_set (subtract (vars_of_type t) unbounds)
	      in 
	      Forall(bv,t)
    in
    map (function (x,ts,i) -> build_type_scheme ts) env
  )
;;

(*---------------------------------------------------------------------*)
(*--- shorten indirections to types -----------------------------------*)
(*---------------------------------------------------------------------*)

let rec shorten t =
    match 
      t 
    with
	TypeVar{Index = _; Value = Unknown}  -> t
      | TypeVar({Index = _; Value = TypeVar{Index =_ ; Value = Unknown} as tv}) 
					     -> tv
      | TypeVar({Index = _; Value = TypeVar tv1} as tv2) 
					     -> tv2.Value 
					     <- tv1.Value; shorten t
      | TypeVar{Index = _; Value = t'}	     -> t'
      | Unknown				     -> raise (TypingBug "shorten")
      | Arrow(t1,t2)			     -> Arrow(shorten t1, shorten t2)
      | Atom str			     -> Atom str
;;

(*---------------------------------------------------------------------*)
(*--- occurs check: catch recursive types -----------------------------*)
(*---------------------------------------------------------------------*)

let occurs {Index = n; Value = _} =
  let rec occrec = function
	TypeVar{Index = m; Value = Unknown} -> (n == m)
      | TypeVar{Index = _; Value = t}	    -> (occrec t)
      | Arrow(t1,t2)			    -> (occrec t1) or (occrec t2)
      | Unknown				    -> raise (TypingBug "occurs")
      | Atom _				    -> false
  in 
  occrec
;;

(*---------------------------------------------------------------------*)
(*--- "destructive" unification ---------------------------------------*)
(*---------------------------------------------------------------------*)

let rec unify (tau1,tau2) =
  match 
    (shorten tau1, shorten tau2)
  with
      (* type variable n and type variable m *)
      
      (TypeVar({Index = n; Value = Unknown} as tv1) as t1),
      (TypeVar({Index = m; Value = Unknown} as tv2) as t2)
			-> if n = m then () else tv1.Value <- t2
			     
      (* type t1 and type variable *)
      
    | t1, (TypeVar({Index = _; Value = Unknown} as tv) as t2)
			-> if not(occurs tv t1) then 
			     tv.Value <- t1
			   else 
			     raise (TypeClash(t1, t2))
			     
      (* type variable and type t2 *)
      
    | (TypeVar({Index = _; Value = Unknown} as tv) as t1), t2
			-> if not(occurs tv t2) then 
			     tv.Value <- t2
			   else 
			     raise (TypeClash(t1, t2))
   
    | Arrow(t1,t2), Arrow(t'1,t'2)
			-> unify(t1,t'1); unify(t2,t'2)
   
    | (Atom str1 as t1), (Atom str2 as t2)
			-> if neq_string str1 str2 then 
			     raise (TypeClash(t1,t2))

    | (t1,t2)		-> raise (TypeClash(t1,t2))
;;

(*--------------------------------------------------------------------*)
(*--- generalize -----------------------------------------------------*)
(*--------------------------------------------------------------------*)

let generalise_type (gamma, tau) =
    let genvars = 
        make_set (subtract (vars_of_type tau) (unknowns_of_type_env gamma))
    in 
    Forall(genvars,tau)
;;

(*--------------------------------------------------------------------*)
(*--- generic instantiation ------------------------------------------*)
(*--------------------------------------------------------------------*)
(*
     associate a new unknown to each generic variable;
     returns a type, not a scheme!
*)

let gen_instance (Forall(gv,tau)) = 
    let unknowns = map (function n -> n, TypeVar(new_vartype())) gv
    in 
    ginstance tau
    where rec ginstance = function
        (TypeVar{Index = n; Value = Unknown} as t) -> (try 
                                                       assoc n unknowns
                                                       with Not_found -> t)
     |  TypeVar {Index = _; Value = t} -> ginstance t
     |  Atom str                       -> Atom str
     |  Arrow(t1,t2)                   -> Arrow(ginstance t1, ginstance t2)
     |  Unknown                        -> raise (TypingBug "gen_instance")
;;

(*--------------------------------------------------------------------*)
(*--- obtain basis type scheme from environment ----------------------*)
(*--------------------------------------------------------------------*)
(*
    x is a string "@n", where n is an index into the
    typing environment constructed at parse time.
*)

let type_scheme_of x env =
  try
    nth (int_of_string (sub_string x 1 ((string_length x)-1))) env
  with Failure _ -> raise (TypingBug "Unbound")
;;

(*--------------------------------------------------------------------*)
(*--- Type a parse tree ----------------------------------------------*)
(*--------------------------------------------------------------------*)
(*
let rec Type gamma = type_rec
  where rec type_rec = function
      Var n -> let sigma =
		try nth n gamma
	        with Failure _ -> raise (TypingBug "Unbound")
	       in gen_instance sigma
    | App((Abs(x,e2) as f), e1) -> (* "LET case" *)
        let t1 = type_rec e1 in
        if nth_char x 0 = `@` then  (* typed variable *)
          begin
            let tau = gen_instance (type_scheme_of x gamma) in
            unify(tau,t1)
          end;
        let sigma = generalise_type (gamma,t1) in 
        Type (sigma :: gamma) e2
    | App(e1,e2) ->
	let u = TypeVar(new_vartype()) in 
        unify(type_rec e1,Arrow(type_rec e2,u)); u
    | Abs(x,e) ->
        if nth_char x 0 = `@` then  (* typed variable *)
          begin
            let sigma = type_scheme_of x gamma
            in
            Arrow(gen_instance sigma,Type (sigma :: gamma) e)
          end
        else
          begin
	    let u = TypeVar(new_vartype()) in
            let s = Forall([],u) in 
            Arrow(u,Type (s :: gamma) e)
          end
;;
*)

let rec Type gamma = type_rec
  where rec type_rec = function
      Var n -> let sigma =
		try nth n gamma
	        with Failure _ -> raise (TypingBug "Unbound")
	       in gen_instance sigma
    | App((Abs(x,e2) as f), e1) -> (* "LET case" *)
        let t1 = type_rec e1 in
        if nth_char x 0 = `@` then  (* typed variable *)
          begin
            let tau = gen_instance (type_scheme_of x gamma) in
            unify(tau,t1)
          end;
        let sigma = generalise_type (gamma,t1) in 
        Type (sigma :: gamma) e2
    | App(e1,e2) ->
	let u = TypeVar(new_vartype()) in 
        unify(type_rec e1,Arrow(type_rec e2,u)); u
    | Abs(x,e) ->
        if nth_char x 0 = `@` then  (* typed variable *)
          begin
            let u = gen_instance (type_scheme_of x gamma) in
            let s = Forall([],u) in 
            Arrow(u,Type (s :: gamma) e)
          end
        else
          begin
	    let u = TypeVar(new_vartype()) in
            let s = Forall([],u) in 
            Arrow(u,Type (s :: gamma) e)
          end
;;

(*--------------------------------------------------------------------*)
(*--- (long) print a type scheme -------------------------------------*)
(*--------------------------------------------------------------------*)
(*
    print generic variables with numeric names and unknowns
    with alpha names, standardized.
*)

let print_type_scheme (Forall(gv,t)) =
  let rec names_of namefun = function
	(n,[])         -> []
      | (n,(v1 :: Lv)) -> (namefun n) :: (names_of namefun (n+1, Lv))
  in
  let names = names_of numeric_name (1,gv)
  in
  let bounds = combine (rev gv, names)
  in
  let ub = unknowns_of_type (gv,t)
  in
  let unbounds = combine (rev ub, names_of alpha_name (1,ub))
  in
  print_string "("; 
  print_string (list_to_string (function n -> n) names); 
  print_string ").";
  let rec print_rec = function
      TypeVar{Index = n; Value = Unknown} 
		      -> let name = (try assoc n bounds
			             with Not_found 
			               -> try assoc n unbounds
			                  with Not_found -> 
			                  raise (TypingBug "print_type_scheme")
			            )
	                 in print_string name
    | TypeVar{Index = _; Value = t} -> print_rec t
    | Arrow(t1,t2)    -> print_string "("; print_rec t1;
			 print_string "->"; print_rec t2;
			 print_string ")"
    | Atom str        -> print_string ("atom "^str)
    | Unknown         -> raise (TypingBug "print_type_scheme")
  in
  print_rec t
;;

(*--- (long) write version ------------------------------------------*)

let write_type_scheme (Forall(gv,t)) =
  let rec names_of namefun = function
	(n,[])         -> []
      | (n,(v1 :: Lv)) -> (namefun n) :: (names_of namefun (n+1, Lv))
  in
  let names = names_of numeric_name (1,gv)
  in
  let bounds = combine (rev gv, names)
  in
  let ub = unknowns_of_type (gv,t)
  in
  let unbounds = combine (rev ub, names_of alpha_name (1,ub))
  in
  let rec write_rec = function
      TypeVar{Index = n; Value = Unknown} 
		      -> (try assoc n bounds
			  with Not_found 
			   -> try assoc n unbounds
			      with Not_found -> 
			      raise (TypingBug "write_type_scheme")
			 )
    | TypeVar{Index = _; Value = t} -> write_rec t
    | Arrow(t1,t2)    -> "("^(write_rec t1)^"->"^(write_rec t2)^")"
    | Atom str        -> "atom "^str
    | Unknown         -> raise (TypingBug "write_type_scheme")
  in
  "("^(list_to_string (function n -> n) names)^")."^write_rec t
;;

(*--------------------------------------------------------------------*)
(*--- wrapper for Type -----------------------------------------------*)
(*--------------------------------------------------------------------*)

let Type_Inference expr = 
  try
    let env = make_set (make_environment expr)
    in
    let pexpr = Parse env (lexer (stream_of_string expr))
    in
    let typing_env = generate_typing_env env
    in
    let result = Type typing_env pexpr
    in
    write_type_scheme (generalise_type (typing_env, result))
  with 
      IllegalChar c	->  "IllegalChar: "^char_for_read c
    | TypingBug str	->  "TypingBug: "^str
    | ParseErr		->  "ParseErr"
    | TypeClash (t1,t2) ->  let vars = vars_of_type(t1) @ vars_of_type(t2) 
			    in
                             "Clash: "^
                             write_type_scheme (Forall(vars, t1))^" and "^
                             write_type_scheme (Forall(vars, t2))
;;

